(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{440:function(t,v,_){"use strict";_.r(v);var a=_(25),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"接口和抽象类的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类的区别"}},[t._v("#")]),t._v(" 接口和抽象类的区别")]),t._v(" "),_("p",[_("strong",[t._v("抽象类")]),t._v("的定义语法为"),_("strong",[t._v("abstract")])]),t._v(" "),_("p",[_("strong",[t._v("接口")]),t._v("的定义语法为"),_("strong",[t._v("interface")])]),t._v(" "),_("h2",{attrs:{id:"抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),_("p",[t._v("抽象类：abstract + 类")]),t._v(" "),_("p",[t._v("抽象方法：abstract + 方法 抽象方法只有方法的声明，没有方体")]),t._v(" "),_("ol",[_("li",[t._v("抽象类不能被实例化，只能被继承；")]),t._v(" "),_("li",[t._v("包含抽象方法的一定是抽象类，抽象类不一定含有抽象方法；")]),t._v(" "),_("li",[t._v("抽象方法的修饰符为：public、protected，默认为public；")]),t._v(" "),_("li",[t._v("一个子类继承抽象类时，必须实现父类中所有的抽象方法，否则子类也是抽象类；")]),t._v(" "),_("li",[t._v("抽象类可以包含属性、方法、构造方法，构造方法不能用于构造实例，主要用途是被子类调用。")])]),t._v(" "),_("h2",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),_("p",[t._v("接口：interface + 接口")]),t._v(" "),_("ol",[_("li",[t._v("接口可以包括变量、方法，变量隐式指定为public static final（子类不能重写），方法隐式指定为public abstract（子类需要重写） (jdk1.8 之前)；")]),t._v(" "),_("li",[t._v("一个接口可以继承多个接口，一个类可以实现多个接口；")]),t._v(" "),_("li",[t._v("jdk1.8新特性\n"),_("ul",[_("li",[t._v("默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；")]),t._v(" "),_("li",[t._v("静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。")])])])]),t._v(" "),_("h2",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("p",[t._v("相同：")]),t._v(" "),_("ul",[_("li",[t._v("都不能被实例化")]),t._v(" "),_("li",[t._v("实现类或子类只有实现了接口或抽象类的方法之后才能实例化")])]),t._v(" "),_("p",[t._v("不同：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("接口")]),t._v("强调功能的实现，"),_("strong",[t._v("抽象类")]),t._v("强调所属关系。从设计层面来说，"),_("strong",[t._v("抽象类")]),t._v("是对类的抽象，是一种模板设计，"),_("strong",[t._v("接口")]),t._v("是行为的抽象，是一种行为的规范。")]),t._v(" "),_("li",[_("strong",[t._v("接口")]),t._v("只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而"),_("strong",[t._v("抽象类")]),t._v("可以有定义与实现，方法可在抽象类中实现。")]),t._v(" "),_("li",[_("strong",[t._v("接口")]),t._v("成员变量默认为public static final，必须赋初值且不能修改，成员方法都是public、abstract；"),_("strong",[t._v("抽象类")]),t._v("中成员变量默认default，在子类中可以重新定义和赋值")]),t._v(" "),_("li",[t._v("实现"),_("strong",[t._v("接口")]),t._v("的关键字时implements，一个类可以实现多个接口。继承"),_("strong",[t._v("抽象类")]),t._v("的关键字为extends，一个类只能实现一个抽象类。")])]),t._v(" "),_("p",[t._v("参考："),_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/94770324",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java基础之接口与抽象类的区别"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=r.exports}}]);